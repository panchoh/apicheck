For Pentesters
==============

Track API Session and export to BurpSuite / OWASP ZAP
-----------------------------------------------------

Sometimes it is useful to store the browsing navigation for an specific API. You can do this using **BurpSuite**, **OWASP ZAP** or any other similar software. But these programs store the navigation using their own format, not a standardized one.

``APICheck`` proxy stores the browsing navigation in a standard RDBMS (MySQL, PostgresSQL, SQLite...), so you can:

- Find any information using SQL queries or using visual database browsers.
- Re-inject the stored traffic to another tool.

For the next example we'll focus on the latter:

.. image:: /_static/images/reinject_to_security_tool.png

**1 - Launch the proxy**

To perform that, we first launch ``APICheck`` :doc:`proxy </tools/proxy>` and record a new session:

.. code-block:: console

    > at-proxy -C sqlite:///browsing_reinject.sqlite3

When the proxy starts, an automatically generated **API Version ID** for the browsing session is displayed. You must write it down, since you will need it later.

When you finish browsing, press :samp:`CTRL+C` to stop the proxy.

**2 - Send browsing data to external security tools**

At this point the browsing session is safely stored in the file **browsing_reinject.sqlite3**. Now, with the **API Version ID** that you got earlier we can re-inject the data into the external security tool:

.. code-block:: console

    > ac-dbcat sqlite:///browsing_reinject.sqlite3 | at-sendto --proxy 127.0.0.1:9000

.. note::

   Note that the security tool you choose must behave like a proxy, with the port
   9000 open.


Tracking API versions
---------------------

``APICheck`` allows you to track API Versions. It offers two ways to track them:

- Using the proxy: each time the proxy starts, it creates a new unique version for that domain and endpoints. This version will be the same if the endpoints and the server are the same.
- Using OpenAPI 3: You can load an OpenAPI 3 specification. ``APICheck`` tracks the version from the definition version.

Once you have the API definitions loaded into ``APICheck``, you can check their versions and history.


.. image:: /_static/images/api_versions.png
   :align: center

To check the versions, you can use the action :samp:`apis` in the :samp:`manage` tool:

.. code-block:: console

    > at-manage apis


Endpoint fuzzing using OpenAPI definitions
------------------------------------------

``APICheck`` can generate random data for a specific API endpoint, using an OpenAPI 3 API definition as a template.

For this example, we'll take this API definition:

.. _api_definition:

.. image:: /_static/images/api_definition.png
   :align: center
   :scale: 80%

.. note::

    ``APICheck`` uses **Faker** to generate data. Therefore, it supports all Faker data types. You can check the list of `supported types here <https://faker.readthedocs.io/en/stable/providers.html>`_

We'll generate fuzzing data for the endpoint :samp:`/products/{productId}`

.. code-block:: yaml
   :linenos:
   :emphasize-lines: 11,16,19,23,28

    name: "my library api"
    description: "OpenAPI 3 fuzzing example"
    version: "0.9-RC"
    tags:
        - books
        - products
    global:
        headers:
            Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
    endpoints:
        /products/{productId}:
            pathParams:
                productId: 500
            post:
                body:
                    name:
                        type: string
                        maxLength: 40
                    price:
                        type: number
                        minimum: -10
                        maximum: 3000000
                    description:
                        type: string
                        format: random
                        minLength: 10000
                        maxLength: 20000
                    type:
                        type: dictionary
                        values:
                            - -1
                            - 0
                            - 1
                            - 100000000


Discovering SQL injection vulnerabilities with API definitions
--------------------------------------------------------------

As in the previous example, we can customize the data generation to perform attacks from the API definition.

In this example, we'll use the same :ref:`API definition <api_definition>`, and use SQL injections from a dictionary file:

For the users *admin* and *root* we build queries that contains common injections using a dictionary file (:samp:`sql_injections.txt`).

.. code-block:: yaml
   :linenos:
   :emphasize-lines: 11,14,21

    name: "my library api"
    description: "SQL Injection example"
    version: "0.9-RC"
    tags:
        - books
        - users
    global:
        headers:
            Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
    endpoints:
        /{user}/search:
            pathParams:
                user:
                    type: dictionary
                    values:
                        - admin
                        - root
            post:
                body:
                    query:
                        type: file
                        file: sql_injections.txt


User Enumeration using API definition
-------------------------------------

.. todo::

    Use case description.


Weak password check using parametrized fuzzing
----------------------------------------------

.. todo::

    Use case description.
